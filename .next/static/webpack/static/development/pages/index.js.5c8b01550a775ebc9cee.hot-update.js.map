{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.5c8b01550a775ebc9cee.hot-update.js","sources":["webpack:///./store/fnReducer.js"],"sourcesContent":["//财务专家\r\n\r\nimport axios from 'axios'\r\nimport * as moduleMyfunc from '../store/myFunc.js'\r\n\r\n\r\n//客户托管在这里的默认的state对象\r\nlet defaultState = {\r\n    // url_BigObjJsonKollins: './static/+json所有柯林斯单词.json', //kollins json路径\r\n    url_BigArrJsonKollins: './static/+arr所有柯林斯单词.json',\r\n    // obj_AllWords: {}, //存放从json文件(一个大的obj对象)中读取到的obj_objJson\r\n    arr_KollinsAllWords: [], //存放从json文件(一个大的数组)中读取到的arr_objJson\r\n\r\n    word_currentFind: '', //当前查找的词头\r\n    index_wordCurrentFind: -1, //当前查找的单词, 在arr_AllWords中的索引值\r\n\r\n    num_OfElementsInSlice: 0, //想切含有多少个元素的切片? 范围是多少? 比如20个元素, 还是30个元素?\r\n    index_start: 0, //数组切片的起始索引值\r\n    index_end: 19, //数组切片的尾索引值\r\n    arr_wordNameInSlice: [], //存放对数组切片后, 里面的所有词头组成的数组\r\n\r\n    word_name: '', //词头\r\n    word_ciGeng: '', //词根\r\n    word_yinBiao: '', //音标\r\n    word_ArrDef: [], //释例数组, 已经过扁平化一维处理.\r\n\r\n    arr_selectedContent: [], //存放选出的释义与例句内容\r\n    str_textArea: '', //将选出的内容,放入文本框中. 方便发送给后端node.js来另存文件.\r\n}\r\n\r\n\r\n//先从json文件中, 拿到所有的kollins单词数据, 并赋值给defaultState对象的arr_KollinsAllWords属性\r\nfn_Set_ArrAllWords() //调用函数\r\n\r\n//拿到Window.localStorage中的数据\r\nfn_getWindowLocalStorage()\r\n\r\n\r\n//财务专家函数\r\nlet fnReducer = (state = defaultState, objAction) => {\r\n    // console.log('财务专家收到命令书', objAction);\r\n\r\n    if (objAction.type === '命令书_更新WordCurrentFind') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.word_currentFind = objAction.value\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_更新indexStart') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.index_start = objAction.value\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_更新indexEnd') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.index_end = objAction.value\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_更新arr_selectedContent') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.arr_selectedContent.push(objAction.value)\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_从选出内容的数组中删除本元素') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        let index = objAction.value //要删除的数组元素的索引值\r\n        newState.arr_selectedContent.splice(index, 1)//删除数组中指定索引处的元素. arrayObject.splice(index,howmany,item1,.....,itemX)\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_更新str_textArea') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        let str = ''\r\n        let str词头 = newState.word_name + '\\r\\n'\r\n        let str音标 = newState.word_yinBiao + '\\r\\n'\r\n        let str词根 = '-> ' + newState.word_ciGeng + '\\r\\n\\r\\n'\r\n\r\n        str = str词头 + str音标 + str词根\r\n\r\n        str += moduleMyfunc.fn_将arr_selectedContent转换成str_textArea(newState.arr_selectedContent)\r\n        newState.str_textArea = str\r\n        return newState\r\n    }\r\n\r\n\r\n    //搜索单个单词,并将内容填充到state中的各对应字段中\r\n    if (objAction.type === '命令书_查找SingleWord') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.word_currentFind = objAction.value\r\n\r\n        // 用 for...of 来做不起作用, 不知原因为何??\r\n        // for (let index = 0; index <= newState.arr_KollinsAllWords.length, index++;) {\r\n        //     if (newState.arr_KollinsAllWords[index][\"key词头\"] === objAction.value) {\r\n        //         newState.index_wordCurrentFind = index\r\n        //         newState.word_name = newState.arr_KollinsAllWords[index][\"key词头\"]\r\n        //         newState.word_yinBiao = newState.arr_KollinsAllWords[index][\"key音标\"]\r\n        //         newState.word_ciGeng = newState.arr_KollinsAllWords[index][\"key词根\"]\r\n        //         newState.word_ArrDef = moduleMyfunc.fn_处理所有释例到一维数组(newState.arr_KollinsAllWords[index][\"key所有释例\"])\r\n        //         newState.arr_selectedContent = [] //当重新查询单词时, 就清空上一次选出的内容\r\n        //         break\r\n        //     }\r\n        // }\r\n        //\r\n\r\n        newState.arr_KollinsAllWords.forEach((itemWord, index, arr) => {\r\n                if (itemWord[\"key词头\"] === objAction.value) {\r\n                    newState.index_wordCurrentFind = index\r\n                    newState.word_name = itemWord[\"key词头\"]\r\n                    newState.word_yinBiao = itemWord[\"key音标\"]\r\n                    newState.word_ciGeng = itemWord[\"key词根\"]\r\n                    newState.word_ArrDef = moduleMyfunc.fn_处理所有释例到一维数组(itemWord[\"key所有释例\"])\r\n                    newState.arr_selectedContent = [] //当重新查询单词时, 就清空上一次选出的内容\r\n                }\r\n            }\r\n        )\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_更新arrWordNameInSlice') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.arr_wordNameInSlice = fn_获取数组切片区间中的词头(newState.arr_KollinsAllWords, newState.index_start, newState.index_end)\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_获取下20个单词') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.index_start = parseInt(newState.index_end) + 1\r\n        newState.index_end = parseInt(newState.index_start) + 19\r\n        newState.arr_wordNameInSlice = fn_获取数组切片区间中的词头(newState.arr_KollinsAllWords, newState.index_start, newState.index_end)\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_获取上20个单词') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.index_start = parseInt(newState.index_start) - 20\r\n        newState.index_end = parseInt(newState.index_end) - 20\r\n        newState.arr_wordNameInSlice = fn_获取数组切片区间中的词头(newState.arr_KollinsAllWords, newState.index_start, newState.index_end)\r\n        return newState\r\n    }\r\n\r\n\r\n    if (objAction.type === '命令书_清空str_textArea') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.str_textArea = '' //除了清空文本框中的值外\r\n        newState.arr_selectedContent = []\r\n        /*也要清空选出的句子, 别忘了这一点!\r\n         因为你添加到str_textArea中的句子, 是从arr_selectedContent中来挑选的,\r\n         如果不清空arr_selectedContent, 里面的残留, 会造成str_textArea里的脏数据.\r\n         */\r\n        return newState\r\n    }\r\n\r\n    if (objAction.type === '命令书_可编辑str_textArea') {\r\n        let newState = JSON.parse(JSON.stringify(state))\r\n        newState.str_textArea = objAction.value\r\n        return newState\r\n    }\r\n\r\n\r\n    return state //如果没有进入上面的if语句而返回一个newState, 本函数也要返回一个默认的defaultState.\r\n}\r\n\r\nexport default fnReducer\r\n\r\n\r\n//----------------------------------------\r\n\r\n//从json文件中, 拿到所有的kollins单词数据, 返回一个promise对象\r\nasync function fnPms_getWordArr_FromJsonFile(urlJson) {\r\n    let Pms_ArrAllWords = await axios.get(urlJson)\r\n        .then(res => {\r\n            return res.data\r\n        })\r\n        .catch(err => {\r\n            console.log(err);\r\n        })\r\n    return Pms_ArrAllWords\r\n}\r\n\r\n\r\n//将拿到的所有柯林斯单词, 赋值给defaultState对象的arr_AllWords属性\r\nfunction fn_Set_ArrAllWords() {\r\n    fnPms_getWordArr_FromJsonFile(defaultState.url_BigArrJsonKollins)\r\n        .then(res => {\r\n            defaultState.arr_KollinsAllWords = res\r\n        })\r\n        .catch(err => {\r\n            console.log(err);\r\n        })\r\n}\r\n\r\n\r\n//拿到 Window.localStorage对象, 我们把index_start 和 index_end 属性, 存放在Window.localStorage对象中, 免得每次刷新页面, 即提交表单后, 会导致index_start 和 index_end 这两个属性的被重置.\r\nfunction fn_getWindowLocalStorage() {\r\n    let objStorage=window.localStorage;\r\n    objStorage.indexStart = defaultState.index_start //进行初始化\r\n    objStorage.indexEnd = defaultState.index_end\r\n\r\n    \r\n\r\n}\r\n\r\n\r\nfunction fn_获取数组切片区间中的词头(arr, indexStart, indexEnd) {\r\n    let arrSlice = arr.slice(indexStart, indexEnd)\r\n    let arrWordName = arrSlice.map((item, index, arr) => {\r\n        return item['key词头']\r\n    })\r\n    return arrWordName\r\n}\r\n\r\n\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAIA;AACA;AAzBA;AAyBA;AAEA;AACA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAAA;;AAYA;AACA;AACA;;;;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AARA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAaA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}